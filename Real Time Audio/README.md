### Explanation of Real Time Voice Communication Using Analog Communication with GNU Radio and BladeRF

This section details the first part of your software-defined network project, which focuses on real-time voice communication using analog communication. Below is a comprehensive explanation of the `real_time_fm.py` script and the corresponding `real_time_fm.grc` flow graph.

### Overview

The script and flow graph implement a real-time FM (Frequency Modulation) transmitter using GNU Radio and BladeRF. The system processes audio data and transmits it as an FM signal. The key components include audio input, signal processing, and RF transmission.

### Code Explanation

#### `real_time_fm.py`

This Python script, generated by GNU Radio Companion, defines the FM transmission flow graph.

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

#
# SPDX-License-Identifier: GPL-3.0
#
# GNU Radio Python Flow Graph
# Title: Real Time Audio
# Author: Lasidu
# GNU Radio version: 3.10.1.1

from packaging.version import Version as StrictVersion

if __name__ == '__main__':
    import ctypes
    import sys
    if sys.platform.startswith('linux'):
        try:
            x11 = ctypes.cdll.LoadLibrary('libX11.so')
            x11.XInitThreads()
        except:
            print("Warning: failed to XInitThreads()")

from PyQt5 import Qt
from gnuradio import qtgui
from gnuradio.filter import firdes
import sip
from gnuradio import analog
from gnuradio import blocks
from gnuradio import filter
from gnuradio import gr
from gnuradio.fft import window
import sys
import signal
from argparse import ArgumentParser
from gnuradio.eng_arg import eng_float, intx
from gnuradio import eng_notation
from gnuradio import soapy
from gnuradio.qtgui import Range, RangeWidget
from PyQt5 import QtCore

class real_time_fm(gr.top_block, Qt.QWidget):

    def __init__(self):
        gr.top_block.__init__(self, "Real Time Audio", catch_exceptions=True)
        Qt.QWidget.__init__(self)
        self.setWindowTitle("Real Time Audio")
        qtgui.util.check_set_qss()
        try:
            self.setWindowIcon(Qt.QIcon.fromTheme('gnuradio-grc'))
        except:
            pass
        self.top_scroll_layout = Qt.QVBoxLayout()
        self.setLayout(self.top_scroll_layout)
        self.top_scroll = Qt.QScrollArea()
        self.top_scroll.setFrameStyle(Qt.QFrame.NoFrame)
        self.top_scroll_layout.addWidget(self.top_scroll)
        self.top_scroll.setWidgetResizable(True)
        self.top_widget = Qt.QWidget()
        self.top_scroll.setWidget(self.top_widget)
        self.top_layout = Qt.QVBoxLayout(self.top_widget)
        self.top_grid_layout = Qt.QGridLayout()
        self.top_layout.addLayout(self.top_grid_layout)

        self.settings = Qt.QSettings("GNU Radio", "real_time_fm")

        try:
            if StrictVersion(Qt.qVersion()) < StrictVersion("5.0.0"):
                self.restoreGeometry(self.settings.value("geometry").toByteArray())
            else:
                self.restoreGeometry(self.settings.value("geometry"))
        except:
            pass

        ##################################################
        # Variables
        ##################################################
        self.volume = volume = 2
        self.samp_rate = samp_rate = 4e6

        ##################################################
        # Blocks
        ##################################################
        self._volume_range = Range(0, 10, 1, 2, 200)
        self._volume_win = RangeWidget(self._volume_range, self.set_volume, "'volume'", "counter_slider", float, QtCore.Qt.Horizontal)
        self.top_layout.addWidget(self._volume_win)
        self.soapy_bladerf_sink_1 = None
        dev = 'driver=bladerf'
        stream_args = ''
        tune_args = ['']
        settings = ['']

        self.soapy_bladerf_sink_1 = soapy.sink(dev, "fc32", 1, '',
                                  stream_args, tune_args, settings)
        self.soapy_bladerf_sink_1.set_sample_rate(0, samp_rate)
        self.soapy_bladerf_sink_1.set_bandwidth(0, 0.0)
        self.soapy_bladerf_sink_1.set_frequency(0, 433e6)
        self.soapy_bladerf_sink_1.set_frequency_correction(0, 0)
        self.soapy_bladerf_sink_1.set_gain(0, min(max(20.0, 17.0), 73.0))
        self.rational_resampler_xxx_0 = filter.rational_resampler_fff(
                interpolation=500,
                decimation=11,
                taps=[],
                fractional_bw=0)
        self.qtgui_time_sink_x_0 = qtgui.time_sink_c(
            1024, #size
            samp_rate, #samp_rate
            "", #name
            1, #number of inputs
            None # parent
        )
        self.qtgui_time_sink_x_0.set_update_time(0.10)
        self.qtgui_time_sink_x_0.set_y_axis(-1, 1)

        self.qtgui_time_sink_x_0.set_y_label('Amplitude', "")

        self.qtgui_time_sink_x_0.enable_tags(True)
        self.qtgui_time_sink_x_0.set_trigger_mode(qtgui.TRIG_MODE_FREE, qtgui.TRIG_SLOPE_POS, 0.0, 0, 0, "")
        self.qtgui_time_sink_x_0.enable_autoscale(False)
        self.qtgui_time_sink_x_0.enable_grid(False)
        self.qtgui_time_sink_x_0.enable_axis_labels(True)
        self.qtgui_time_sink_x_0.enable_control_panel(False)
        self.qtgui_time_sink_x_0.enable_stem_plot(False)


        labels = ['Signal 1', 'Signal 2', 'Signal 3', 'Signal 4', 'Signal 5',
            'Signal 6', 'Signal 7', 'Signal 8', 'Signal 9', 'Signal 10']
        widths = [1, 1, 1, 1, 1,
            1, 1, 1, 1, 1]
        colors = ['blue', 'red', 'green', 'black', 'cyan',
            'magenta', 'yellow', 'dark red', 'dark green', 'dark blue']
        alphas = [1.0, 1.0, 1.0, 1.0, 1.0,
            1.0, 1.0, 1.0, 1.0, 1.0]
        styles = [1, 1, 1, 1, 1,
            1, 1, 1, 1, 1]
        markers = [-1, -1, -1, -1, -1,
            -1, -1, -1, -1, -1]


        for i in range(2):
            if len(labels[i]) == 0):
                if (i % 2 == 0):
                    self.qtgui_time_sink_x_0.set_line_label(i, "Re{{Data {0}}}".format(i/2))
                else:
                    self.qtgui_time_sink_x_0.set_line_label(i, "Im{{Data {0}}}".format(i/2))
            else:
                self.qtgui_time_sink_x_0.set_line_label(i, labels[i])
            self.qtgui_time_sink_x_0.set_line_width(i, widths[i])
            self.qtgui_time_sink_x_0.set_line_color(i, colors[i])
            self.qtgui_time_sink_x_0.set_line_style(i, styles[i])
            self.qtgui_time_sink_x_0.set_line_marker(i, markers[i])
            self.qtgui_time_sink_x_0.set_line_alpha(i, alphas[i])

        self._qtgui_time_sink_x_0_win = sip.wrapinstance(self.qtgui_time_sink_x_0.qwidget(), Qt.QWidget)
        self.top_layout.addWidget(self._qtgui_time_sink_x_0_win)
        self.qtgui_sink_x_0 = qtgui.sink_c(
            1024, #fftsize
            window.WIN_BLACKMAN_hARRIS, #wintype
            90e6, #fc
            samp_rate, #bw
            "", #name
            True, #plotfreq
            True, #plotwaterfall
            True, #plottime
            True, #plotconst
            None # parent
        )
        self.qtgui_sink_x_0.set_update_time(1.0/10)
        self._qtgui_sink_x_0_win = sip.wrapinstance(self.qtgui_sink_x_0.qwidget(), Qt.QWidget)

        self.qtgui_sink_x_0.enable_rf_freq(False)

        self.top_layout.addWidget(self._qtgui_sink_x_0_win)
        self.blocks_wavfile_source_0 = blocks.wavfile_source("./file_example_WAV_5MG.wav", True)
        self.blocks_multiply_const_vxx_0_0 = blocks.multiply_const_cc(0.3)
        self.blocks_multiply_const_vxx_0 = blocks.multiply_const_ff(volume)
        self.analog_nbfm_tx_0 = analog.nbfm_tx(
        	audio_rate=44100,
        	quad_rate=44100*2,
        	tau=75e-6,
        	max_dev=1e3,
        	fh=-1.0,


                )


        ##################################################
        # Connections
        ##################################################
        self.connect((self.analog_nbfm_tx_0, 0), (self.blocks_multiply_const_vxx_0_0, 0))
        self.connect((self.analog_nbfm_tx_0, 0), (self.qtgui_sink_x_0, 0))
        self.connect((self.analog_nbfm_tx_0, 0), (self.qtgui_time_sink_x_0, 0))
        self.connect((self.blocks_multiply_const_vxx_0, 0), (self.rational_resampler_xxx_0, 0))
        self.connect((self.blocks_multiply_const_vxx_0_0, 0), (self.soapy_bladerf_sink_1, 0))
        self.connect((self.blocks_wavfile_source_0, 0), (self.blocks_multiply_const_vxx_0, 0))
        self.connect((self.rational_resampler_xxx_0, 0), (self.analog_nbfm_tx_0, 0))


    def closeEvent(self, event):
        self.settings = Qt.QSettings("GNU Radio", "real_time_fm")
        self.settings.setValue("geometry", self.saveGeometry())
        self.stop()
        self.wait()

        event.accept()

    def get_volume(self):
        return self.volume

    def set_volume(self, volume):
        self.volume = volume
        self.blocks_multiply_const_vxx_0.set_k(self.volume)

    def get_samp_rate(self):
        return self.samp_rate

    def set_samp_rate(self, samp_rate):
        self.samp_rate = samp_rate
        self.qtgui_sink_x_0.set_frequency_range(90e6, self.samp_rate)
        self.qtgui_time_sink_x_0.set_samp_rate(self.samp_rate)
        self.soapy_bladerf_sink_1.set_sample_rate(0, self.samp_rate)

def main(top_block_cls=real_time_fm, options=None):

    if StrictVersion("4.5.0") <= StrictVersion(Qt.qVersion()) < StrictVersion("5.0.0"):
        style = gr.prefs().get_string('qtgui', 'style', 'raster')
        Qt.QApplication.setGraphicsSystem(style)
    qapp = Qt.QApplication(sys.argv)

    tb = top_block_cls()

    tb.start()

    tb.show()

    def sig_handler(sig=None, frame=None):
        tb.stop()
        tb.wait()

        Qt.QApplication.quit()

    signal.signal(signal.SIGINT, sig_handler)
    signal.signal(signal.SIGTERM, sig_handler)

    timer = Qt.QTimer()
    timer.start(500)
    timer.timeout.connect(lambda: None)

    qapp.exec_()

if __name__ == '__main__':
    main()
```

### Explanation of Each Block and Code Segment

#### Header and Imports
- **Header**: Contains metadata such as the author and GNU Radio version.
- **Imports**: Import necessary libraries and modules, including `Qt`, `GNU Radio`, and other dependencies.

#### Initialization
- **Class Definition**: `real_time_fm` class inherits from `gr.top_block` and `Qt.QWidget`.
- **Window Setup**: Sets up the main window using Qt, including the layout and geometry restoration.

#### Variables
- **Volume**: Controls the audio volume.
- **Sample Rate**: The rate at which samples are processed.

#### Blocks
- **Volume Range Widget**: Allows adjusting the volume through a slider.
- **Soapy BladeRF Sink**: Configures the BladeRF device for transmission.
  - **Device**: Specifies the BladeRF device.
  - **Sample Rate, Bandwidth, Frequency, Gain**: Sets the transmission parameters.
- **Rational Resampler**: Changes the sample rate by a rational factor.
- **QT GUI Time Sink**: Displays the time domain signal.
- **QT GUI Sink**: Provides a graphical interface to view the signal in various domains (frequency, time, etc.).
- **WAV File Source**: Reads audio data from a WAV file.
- **Multiply Const Blocks**: Adjusts the amplitude of the signal.
- **NBFM Transmitter**: Performs narrowband FM modulation.

#### Connections
- **Connections**: Define how data flows between blocks using the `connect` method.

#### Methods
- **get_volume / set_volume**: Methods to get and set the volume.
- **get_samp_rate / set_samp_rate**: Methods to get and set the sample rate.

#### Main Function
- **Main Execution**: Initializes and starts the flow graph, sets up signal handlers for clean exit, and starts the Qt application loop.

### Flow Graph (`real_time_fm.grc`)

#### Variables
- **samp_rate**: Sample rate of 4 MHz.
- **volume**: Initial volume set to 2.

#### Blocks
- **WAV File Source**: Reads audio from a file.
- **Multiply Const**: Adjusts the audio volume.
- **Resampler**: Matches the sample rate for FM modulation.
- **NBFM Transmitter**: Modulates the audio signal using narrowband FM.
- **Soapy BladeRF Sink**: Sends the modulated signal to the BladeRF for transmission.
- **QT GUI Blocks**: Provide visual representations of the signal in time and frequency domains.

#### Connections
- **Audio Processing Chain**: WAV File Source -> Multiply Const -> Resampler -> NBFM Transmitter -> Multiply Const -> BladeRF Sink.
- **Visualization Chain**: NBFM Transmitter -> QT GUI Blocks.

### Implementation

This implementation enables real-time voice communication using analog FM modulation. Audio data is read from a WAV file, processed, modulated, and transmitted using a BladeRF device. The graphical interfaces provided by QT GUI blocks allow monitoring the signal in real-time.

### Conclusion

This section detailed the implementation and components of your real-time FM audio transmission system using GNU Radio and BladeRF. The provided explanations cover each block's purpose, connections, and how the overall system works to achieve real-time analog voice communication.
